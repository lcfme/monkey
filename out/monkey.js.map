{"version":3,"sources":["webpack://monkey/webpack/universalModuleDefinition","webpack://monkey/webpack/bootstrap","webpack://monkey/./lib/index.js","webpack://monkey/./src/ast.js","webpack://monkey/./src/lexer.js","webpack://monkey/./src/monkey.js","webpack://monkey/./src/parser.js","webpack://monkey/./src/token.js"],"names":["Program","statements","length","tokenLiterial","str","i","toString","LetStatement","token","Literial","name","value","Identifier","ReturnStatement","returnValue","ExpressionStatement","expression","IntegerLiteral","PrefixExpression","operator","right","InfixExpression","left","isLiterial","ch","isDigit","Lexer","input","position","readPosition","readChar","tok","skipWhitespace","peekChar","literial","EQ","ASSIGN","SEMICOLON","LPAREN","RPAREN","COMMA","PLUS","LBRACE","RBRACE","MINUS","NOT_EQ","BANG","SLASH","ASTERISK","LT","GT","EOF","readIdentifier","INT","readNumber","ILLEGAL","slice","Parser","TokenTypes","IDENT","lexer","ast","LOWEST","EQUALS","LESSGREATER","SUM","PRODUCT","PREFIX","CALL","precedence","l","errors","prefixParseFns","infixParseFns","registerPrefix","parseIdentifier","parseIntegerLiteral","parsePrefixExpression","registerInfix","parseInfixExpression","nextToken","curToken","peekToken","t","push","tokenType","fn","parseExpression","p","Type","undefined","program","stmt","parseStatememt","LET","parseLetStatement","RETURN","parseReturnStatement","parseExpressionStatement","expectPeek","curTokenIs","peekTokenIs","peekError","prefix","noPrefixParseFnError","leftExp","peekPrecedence","infix","lit","Number","curPrecedence","generateToken","lookupIdent","FUNC","TRUE","FALSE","IF","ELSE","keywords","let","true","false","if","else","return","ident"],"mappings":"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","file":"monkey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"monkey\"] = factory();\n\telse\n\t\troot[\"monkey\"] = factory();\n})(this || window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/index.js\");\n","const monkey = require('../src/monkey');\nmodule.exports = monkey;\nexports = module.exports;\nexports.default = module.exports;\n","// @flow\n\nimport type { Token } from './token';\nexport interface Node {\n  tokenLiterial(): ?string;\n  toString(): string;\n}\n\nexport interface Statement extends Node {\n  statementNode(): void;\n}\n\nexport interface Expression extends Node {\n  expressionNode(): void;\n}\n\nexport class Program {\n  statements: Array<Statement>;\n  constructor() {\n    this.statements = [];\n  }\n  tokenLiterial(): ?string {\n    if (this.statements.length) {\n      return this.statements[0].tokenLiterial();\n    } else {\n      return '';\n    }\n  }\n  toString() {\n    let str = '';\n    for (let i = 0; i < this.statements.length; i++) {\n      str += this.statements[i].toString();\n    }\n    return str;\n  }\n}\n\nexport class LetStatement implements Statement {\n  token: Token;\n  name: Identifier;\n  value: Expression;\n  statementNode() {}\n  tokenLiterial(): string {\n    return this.token.Literial;\n  }\n  toString(): string {\n    let str = this.tokenLiterial() + ' ' + this.name.toString() + ' = ';\n    if (this.value) {\n      str += this.value.toString() + ' ';\n    }\n    str += ';';\n    return str;\n  }\n}\n\nexport class Identifier implements Expression {\n  token: Token;\n  value: string;\n  constructor(token: Token, value: string) {\n    this.token = token;\n    this.value = value;\n  }\n  expressionNode() {}\n  tokenLiterial(): string {\n    return this.token.Literial;\n  }\n  toString(): string {\n    return this.value;\n  }\n}\n\nexport class ReturnStatement implements Statement {\n  token: Token;\n  returnValue: Expression;\n  tokenLiterial(): string {\n    return this.token.Literial;\n  }\n  statementNode() {}\n  toString(): string {\n    let str = this.tokenLiterial();\n    if (this.returnValue) {\n      str += this.returnValue.toString();\n    }\n    str += ';';\n    return str;\n  }\n}\n\nexport class ExpressionStatement implements Statement {\n  token: Token;\n  expression: ?Expression;\n  statementNode() {}\n  tokenLiterial() {\n    return this.token.Literial;\n  }\n  toString(): string {\n    if (this.expression) {\n      return this.expression.toString();\n    }\n    return '';\n  }\n}\n\nexport class IntegerLiteral implements Expression {\n  token: Token;\n  value: number;\n  expressionNode() {}\n  tokenLiterial(): string {\n    return this.token.Literial;\n  }\n  toString(): string {\n    return this.token.Literial;\n  }\n}\n\nexport class PrefixExpression implements Expression {\n  token: Token;\n  operator: string;\n  right: Expression;\n  expressionNode() {}\n  tokenLiterial(): string {\n    return this.token.Literial;\n  }\n  toString(): string {\n    return '(' + this.operator + this.right.toString() + ')';\n  }\n}\n\nexport class InfixExpression implements Expression {\n  token: Token;\n  left: Expression;\n  operator: string;\n  right: Expression;\n  expressionNode() {}\n  tokenLiterial(): string {\n    return this.token.Literial;\n  }\n  toString(): string {\n    return (\n      '(' +\n      this.left.toString() +\n      ' ' +\n      this.operator +\n      ' ' +\n      this.right.toString() +\n      ')'\n    );\n  }\n}\n","// @flow\n\nimport {\n  generateToken,\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  lookupIdent,\n  INT,\n  MINUS,\n  BANG,\n  SLASH,\n  ASTERISK,\n  LT,\n  GT,\n  EQ,\n  NOT_EQ\n} from './token';\nimport type { Token } from './token';\n\nfunction isLiterial(ch: any): boolean {\n  return ch && (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));\n}\n\nfunction isDigit(ch: any): boolean {\n  return ch && ('0' <= ch && ch <= '9');\n}\n\nexport class Lexer {\n  input: string;\n  position: number;\n  readPosition: number;\n  ch: ?string;\n  constructor(input: string) {\n    this.input = input || '';\n    this.position = this.readPosition = 0;\n    this.readChar();\n  }\n  readChar() {\n    if (this.readPosition >= this.input.length) {\n      this.ch = null;\n    } else {\n      this.ch = this.input[this.readPosition];\n    }\n    this.position = this.readPosition;\n    this.readPosition += 1;\n  }\n  peekChar(): ?string {\n    if (this.readPosition >= this.input.length) {\n      return null;\n    }\n    return this.input[this.readPosition];\n  }\n  nextToken(): Token {\n    let tok: Token;\n    this.skipWhitespace();\n\n    switch (this.ch) {\n      case '=':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literial = ((ch: any): string) + ((this.ch: any): string);\n          tok = generateToken(EQ, literial);\n        } else {\n          tok = generateToken(ASSIGN, ((this.ch: any): string));\n        }\n        break;\n      case ';':\n        tok = generateToken(SEMICOLON, this.ch);\n        break;\n      case '(':\n        tok = generateToken(LPAREN, this.ch);\n        break;\n      case ')':\n        tok = generateToken(RPAREN, this.ch);\n        break;\n      case ',':\n        tok = generateToken(COMMA, this.ch);\n        break;\n      case '+':\n        tok = generateToken(PLUS, this.ch);\n        break;\n      case '{':\n        tok = generateToken(LBRACE, this.ch);\n        break;\n      case '}':\n        tok = generateToken(RBRACE, this.ch);\n        break;\n      case '-':\n        tok = generateToken(MINUS, this.ch);\n        break;\n      case '!':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literial = ((ch: any): string) + ((this.ch: any): string);\n          tok = generateToken(NOT_EQ, literial);\n        } else {\n          tok = generateToken(BANG, ((this.ch: any): string));\n        }\n        break;\n      case '/':\n        tok = generateToken(SLASH, this.ch);\n        break;\n      case '*':\n        tok = generateToken(ASTERISK, this.ch);\n        break;\n      case '<':\n        tok = generateToken(LT, this.ch);\n        break;\n      case '>':\n        tok = generateToken(GT, this.ch);\n        break;\n      case null:\n        tok = generateToken(EOF);\n        break;\n      default:\n        if (isLiterial(this.ch)) {\n          const literial = this.readIdentifier();\n          tok = generateToken(lookupIdent(literial), literial);\n          return tok;\n        } else if (isDigit(this.ch)) {\n          tok = generateToken(INT, this.readNumber());\n          return tok;\n        } else {\n          tok = generateToken(ILLEGAL, this.ch);\n        }\n    }\n    this.readChar();\n    return ((tok: any): Token);\n  }\n  readNumber(): string {\n    const position = this.position;\n    while (isDigit(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  readIdentifier(): string {\n    const position = this.position;\n    while (isLiterial(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  skipWhitespace() {\n    while (\n      this.ch === ' ' ||\n      this.ch === '\\t' ||\n      this.ch === '\\n' ||\n      this.ch === '\\r'\n    ) {\n      this.readChar();\n    }\n  }\n}\n","// @flow\nexport { Lexer } from './lexer';\nimport {\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  INT,\n  MINUS,\n  BANG,\n  SLASH,\n  ASTERISK,\n  LT,\n  GT,\n  EQ,\n  NOT_EQ\n} from './token';\n\nexport const TokenTypes = {\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  INT,\n  MINUS,\n  BANG,\n  SLASH,\n  ASTERISK,\n  LT,\n  GT,\n  EQ,\n  NOT_EQ\n};\n\nexport { Parser } from './parser';\n","// @flow\n\nimport * as lexer from './lexer';\nimport * as ast from './ast';\nimport * as token from './token';\n\nconst LOWEST = 1;\nconst EQUALS = 2;\nconst LESSGREATER = 3;\nconst SUM = 4;\nconst PRODUCT = 5;\nconst PREFIX = 6;\nconst CALL = 7;\n\nconst precedence: { [k: any]: number } = {\n  [token.EQ]: EQUALS,\n  [token.NOT_EQ]: EQUALS,\n  [token.LT]: LESSGREATER,\n  [token.GT]: LESSGREATER,\n  [token.PLUS]: SUM,\n  [token.MINUS]: SUM,\n  [token.SLASH]: PRODUCT,\n  [token.ASTERISK]: PRODUCT\n};\n\ntype prefixParseFn = () => ast.Expression;\ntype infixParseFn = ast.Expression => ast.Expression;\n\nexport class Parser {\n  l: lexer.Lexer;\n  curToken: token.Token;\n  peekToken: token.Token;\n  errors: Array<string>;\n  prefixParseFns: { [k: token.TokenType]: prefixParseFn };\n  infixParseFns: { [k: token.TokenType]: infixParseFn };\n  constructor(l: lexer.Lexer) {\n    this.errors = [];\n    this.prefixParseFns = {};\n    this.infixParseFns = {};\n    this.l = l;\n    this.registerPrefix(token.IDENT, this.parseIdentifier);\n    this.registerPrefix(token.INT, this.parseIntegerLiteral);\n    this.registerPrefix(token.BANG, this.parsePrefixExpression);\n    this.registerInfix(token.PLUS, this.parseInfixExpression);\n    this.registerInfix(token.MINUS, this.parseInfixExpression);\n    this.registerInfix(token.SLASH, this.parseInfixExpression);\n    this.registerInfix(token.ASTERISK, this.parseInfixExpression);\n    this.registerInfix(token.EQ, this.parseInfixExpression);\n    this.registerInfix(token.NOT_EQ, this.parseInfixExpression);\n    this.registerInfix(token.LT, this.parseInfixExpression);\n    this.registerInfix(token.GT, this.parseInfixExpression);\n    this.nextToken();\n    this.nextToken();\n  }\n  nextToken() {\n    this.curToken = this.peekToken;\n    this.peekToken = this.l.nextToken();\n  }\n  noPrefixParseFnError(t: token.TokenType) {\n    this.errors.push('no parse function for token ' + t);\n  }\n  registerPrefix(tokenType: token.TokenType, fn: prefixParseFn) {\n    this.prefixParseFns[tokenType] = fn;\n  }\n  registerInfix(tokenType: token.TokenType, fn: infixParseFn) {\n    this.infixParseFns[tokenType] = fn;\n  }\n  parsePrefixExpression(): ast.Expression {\n    const expression = new ast.PrefixExpression();\n    expression.token = this.curToken;\n    expression.operator = this.curToken.Literial;\n    this.nextToken();\n    expression.right = ((this.parseExpression(\n      PREFIX\n    ): any): ast.PrefixExpression);\n    return expression;\n  }\n  peekPrecedence(): number {\n    const p = precedence[this.peekToken.Type];\n    if (p !== undefined) {\n      return p;\n    }\n    return LOWEST;\n  }\n  curPrecedence(): number {\n    const p = precedence[this.curToken.Type];\n    if (p !== undefined) {\n      return p;\n    }\n    return LOWEST;\n  }\n  parseProgram(): ast.Program {\n    const program = new ast.Program();\n    while (this.curToken.Type !== token.EOF) {\n      const stmt = this.parseStatememt();\n      if (stmt) {\n        program.statements.push(stmt);\n      }\n      this.nextToken();\n    }\n    return program;\n  }\n  parseIdentifier(): ast.Expression {\n    return new ast.Identifier(this.curToken, this.curToken.Literial);\n  }\n  parseStatememt(): ?ast.Statement {\n    switch (this.curToken.Type) {\n      case token.LET:\n        return this.parseLetStatement();\n      case token.RETURN:\n        return this.parseReturnStatement();\n      default:\n        return this.parseExpressionStatement();\n    }\n  }\n  parseLetStatement(): ?ast.LetStatement {\n    const stmt = new ast.LetStatement();\n    stmt.token = this.curToken;\n    if (!this.expectPeek(token.IDENT)) {\n      return;\n    }\n    stmt.name = new ast.Identifier(this.curToken, this.curToken.Literial);\n    if (!this.expectPeek(token.ASSIGN)) {\n      return;\n    }\n    // @TODO\n    while (\n      this.curToken.Type !== token.EOF &&\n      !this.curTokenIs(token.SEMICOLON)\n    ) {\n      this.nextToken();\n    }\n    return stmt;\n  }\n  parseReturnStatement(): ast.ReturnStatement {\n    const stmt = new ast.ReturnStatement();\n    stmt.token = this.curToken;\n    this.nextToken();\n\n    // @TODO\n    while (\n      this.curToken.Type !== token.EOF &&\n      !this.curTokenIs(token.SEMICOLON)\n    ) {\n      this.nextToken();\n    }\n\n    return stmt;\n  }\n  expectPeek(t: token.TokenType): boolean {\n    if (this.peekTokenIs(t)) {\n      this.nextToken();\n      return true;\n    } else {\n      this.peekError(t);\n      return false;\n    }\n  }\n\n  peekError(t: token.TokenType) {\n    this.errors.push(\n      `expected next token to be ${t} but got ${this.peekToken.Type}`\n    );\n  }\n  peekTokenIs(t: token.TokenType): boolean {\n    return this.peekToken.Type === t;\n  }\n  curTokenIs(t: token.TokenType): boolean {\n    return this.curToken.Type === t;\n  }\n\n  parseExpressionStatement(): ast.ExpressionStatement {\n    const stmt = new ast.ExpressionStatement();\n    stmt.token = this.curToken;\n    stmt.expression = this.parseExpression(LOWEST);\n    return stmt;\n  }\n  parseExpression(precedence: number): ?ast.Expression {\n    const prefix = this.prefixParseFns[this.curToken.Type];\n    if (!prefix) {\n      this.noPrefixParseFnError(this.curToken.Type);\n      return null;\n    }\n    let leftExp = prefix();\n    while (\n      this.curToken.Type !== token.EOF &&\n      !this.curTokenIs(token.SEMICOLON) &&\n      precedence < this.peekPrecedence()\n    ) {\n      const infix = this.infixParseFns[this.peekToken.Type];\n      if (!infix) {\n        return leftExp;\n      }\n      this.nextToken();\n      leftExp = infix(leftExp);\n    }\n    return leftExp;\n  }\n  parseIntegerLiteral(): ast.Expression {\n    const lit = new ast.IntegerLiteral();\n    lit.token = this.curToken;\n    lit.value = Number(this.curToken.Literial);\n    return lit;\n  }\n  parseInfixExpression(left: ast.Expression): ast.Expression {\n    const expression = new ast.InfixExpression();\n    expression.token = this.curToken;\n    expression.operator = this.curToken.Literial;\n    expression.left = left;\n\n    const precedence = this.curPrecedence();\n    this.nextToken();\n    expression.right = ((this.parseExpression(\n      precedence\n    ): any): ast.Expression);\n    return expression;\n  }\n}\n","// @flow\n\nexport type TokenType = string;\n\nexport interface Token {\n  Type: TokenType;\n  Literial: string;\n}\n\nexport function generateToken(\n  tokenType: TokenType,\n  literial: string = ''\n): Token {\n  return {\n    Type: tokenType,\n    Literial: literial\n  };\n}\n\nexport const ILLEGAL = 'ILLEGAL';\nexport const EOF = 'EOF';\nexport const IDENT = 'ident';\nexport const INT = 'int';\nexport const ASSIGN = '=';\nexport const PLUS = '+';\nexport const COMMA = ',';\nexport const SEMICOLON = ';';\nexport const LPAREN = '(';\nexport const RPAREN = ')';\nexport const LBRACE = '{';\nexport const RBRACE = '}';\nexport const FUNC = 'function';\nexport const LET = 'let';\nexport const MINUS = '-';\nexport const BANG = '!';\nexport const ASTERISK = '*';\nexport const SLASH = '/';\nexport const LT = '<';\nexport const GT = '>';\nexport const TRUE = 'true';\nexport const FALSE = 'false';\nexport const IF = 'if';\nexport const ELSE = 'else';\nexport const RETURN = 'return';\nexport const EQ = '==';\nexport const NOT_EQ = '!=';\n\nexport const keywords = {\n  fn: FUNC,\n  let: LET,\n  true: TRUE,\n  false: FALSE,\n  if: IF,\n  else: ELSE,\n  return: RETURN\n};\n\nexport function lookupIdent(ident: string) {\n  const tokenType = keywords[ident];\n  if (tokenType) {\n    return tokenType;\n  }\n  return IDENT;\n}\n"],"sourceRoot":""}