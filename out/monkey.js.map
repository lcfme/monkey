{"version":3,"sources":["webpack://Monkey/webpack/universalModuleDefinition","webpack://Monkey/webpack/bootstrap","webpack://Monkey/./lib/index.js","webpack://Monkey/./src/lexer.js","webpack://Monkey/./src/token.js"],"names":["isLiterial","ch","isDigit","Lexer","input","position","readPosition","readChar","length","undefined","tok","skipWhitespace","ASSIGN","SEMICOLON","LPAREN","RPAREN","COMMA","PLUS","LBRACE","RBRACE","EOF","literial","readIdentifier","ILLEGAL","slice","generateToken","lookupIdent","tokenType","Type","Literial","IDENT","INT","FUNC","LET","keywords","fn","let","ident"],"mappings":"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","file":"monkey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Monkey\"] = factory();\n\telse\n\t\troot[\"Monkey\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/index.js\");\n","const Monkey = require('../src/lexer');\n\nmodule.exports = Monkey.default;\n\nexports = module.exports;\n\nexports.default = module.exports;\n","// @flow\n\nimport {\n  generateToken,\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  lookupIdent\n} from './token';\nimport type { Token } from './token';\n\nfunction isLiterial(ch: any): boolean {\n  return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z');\n}\n\nfunction isDigit(ch: any): boolean {\n  return '0' <= ch && ch <= '9';\n}\n\nexport class Lexer {\n  input: string;\n  position: number;\n  readPosition: number;\n  ch: string | void;\n  constructor(input: string) {\n    this.input = input || '';\n    this.position = this.readPosition = 0;\n    this.readChar();\n  }\n  readChar() {\n    if (this.readPosition >= this.input.length) {\n      this.ch = undefined;\n    } else {\n      this.ch = this.input[this.readPosition++];\n    }\n    this.position = this.readPosition;\n  }\n  nextToken(): Token {\n    let tok: Token;\n    this.skipWhitespace();\n\n    switch (this.ch) {\n      case '=':\n        tok = generateToken(ASSIGN, this.ch);\n        break;\n      case ';':\n        tok = generateToken(SEMICOLON, this.ch);\n        break;\n      case '(':\n        tok = generateToken(LPAREN, this.ch);\n        break;\n      case ')':\n        tok = generateToken(RPAREN, this.ch);\n        break;\n      case ',':\n        tok = generateToken(COMMA, this.ch);\n        break;\n      case '+':\n        tok = generateToken(PLUS, this.ch);\n        break;\n      case '{':\n        tok = generateToken(LBRACE, this.ch);\n        break;\n      case '}':\n        tok = generateToken(RBRACE, this.ch);\n        break;\n      case undefined:\n        tok = generateToken(EOF);\n        break;\n      default:\n        if (isLiterial(this.ch)) {\n          const literial = this.readIdentifier();\n          tok = generateToken(lookupIdent(literial), literial);\n          return tok;\n        } else if (isDigit(this.ch)) {\n        } else {\n          tok = generateToken(ILLEGAL, this.ch);\n        }\n    }\n    this.readChar();\n    return ((tok: any): Token);\n  }\n  readNumber(): string {\n    const position = this.position;\n    while (isDigit(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  readIdentifier(): string {\n    const position = this.position;\n    while (isLiterial(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  skipWhitespace() {\n    while (\n      this.ch === ' ' ||\n      this.ch === '\\t' ||\n      this.ch === '\\n' ||\n      this.ch === '\\r'\n    ) {\n      this.readChar();\n    }\n  }\n}\n","// @flow\nexport type TokenType = string;\n\nexport interface Token {\n  Type: TokenType;\n  Literial: string | void;\n}\n\nexport function generateToken(tokenType: TokenType, literial?: string): Token {\n  return {\n    Type: tokenType,\n    Literial: literial\n  };\n}\n\nexport const ILLEGAL = 'ILLEGAL';\nexport const EOF = 'EOF';\nexport const IDENT = 'ident';\nexport const INT = 'int';\nexport const ASSIGN = '=';\nexport const PLUS = '+';\nexport const COMMA = ',';\nexport const SEMICOLON = ';';\nexport const LPAREN = '(';\nexport const RPAREN = ')';\nexport const LBRACE = '{';\nexport const RBRACE = '}';\nexport const FUNC = 'function';\nexport const LET = 'let';\n\nexport const keywords = {\n  fn: FUNC,\n  let: LET\n};\n\nexport function lookupIdent(ident: string) {\n  const tokenType = keywords[ident];\n  if (tokenType) {\n    return tokenType;\n  }\n  return IDENT;\n}\n"],"sourceRoot":""}