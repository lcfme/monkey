{"version":3,"sources":["webpack://monkey/webpack/universalModuleDefinition","webpack://monkey/webpack/bootstrap","webpack://monkey/./lib/index.js","webpack://monkey/./src/ast.js","webpack://monkey/./src/lexer.js","webpack://monkey/./src/monkey.js","webpack://monkey/./src/parser.js","webpack://monkey/./src/token.js"],"names":["Program","statements","length","tokenLiterial","LetStatement","token","Literial","Identifier","value","isLiterial","ch","isDigit","Lexer","input","position","readPosition","readChar","tok","skipWhitespace","peekChar","literial","EQ","ASSIGN","SEMICOLON","LPAREN","RPAREN","COMMA","PLUS","LBRACE","RBRACE","MINUS","NOT_EQ","BANG","SLASH","ASTERISK","LT","GT","EOF","readIdentifier","INT","readNumber","ILLEGAL","slice","Parser","TokenTypes","IDENT","lexer","ast","l","errors","nextToken","curToken","peekToken","program","Type","stmt","parseStatememt","push","LET","parseLetStatement","expectPeek","name","curTokenIs","t","peekTokenIs","peekError","generateToken","lookupIdent","tokenType","FUNC","TRUE","FALSE","IF","ELSE","RETURN","keywords","fn","let","true","false","if","else","return","ident"],"mappings":"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","file":"monkey.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"monkey\"] = factory();\n\telse\n\t\troot[\"monkey\"] = factory();\n})(this || window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/index.js\");\n","const monkey = require('../src/monkey');\nmodule.exports = monkey;\nexports = module.exports;\nexports.default = module.exports;\n","// @flow\n\nimport type { Token } from './token';\nexport interface Node {\n  tokenLiterial(): string;\n}\n\nexport interface Statement extends Node {\n  statementNode(): void;\n}\n\nexport interface Expression extends Node {\n  expressionNode(): void;\n}\n\nexport class Program {\n  statements: Array<Statement>;\n  constructor() {\n    this.statements = [];\n  }\n  tokenLiterial(): string {\n    if (this.statements.length) {\n      return this.statements[0].tokenLiterial();\n    } else {\n      return '';\n    }\n  }\n}\n\nexport class LetStatement implements Statement {\n  token: Token;\n  name: Identifier;\n  value: Expression;\n  constructor() {}\n  statementNode() {}\n  tokenLiterial(): string {\n    return ((this.token.Literial: any): string);\n  }\n}\n\nexport class Identifier implements Expression {\n  token: Token;\n  value: ?string;\n  constructor(token: Token, value: ?string) {\n    this.token = token;\n    this.value = value;\n  }\n  expressionNode() {}\n  tokenLiterial(): string {\n    return ((this.token.Literial: any): string);\n  }\n}\n","// @flow\n\nimport {\n  generateToken,\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  lookupIdent,\n  INT,\n  MINUS,\n  BANG,\n  SLASH,\n  ASTERISK,\n  LT,\n  GT,\n  EQ,\n  NOT_EQ\n} from './token';\nimport type { Token } from './token';\n\nfunction isLiterial(ch: any): boolean {\n  return ch && (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));\n}\n\nfunction isDigit(ch: any): boolean {\n  return ch && ('0' <= ch && ch <= '9');\n}\n\nexport class Lexer {\n  input: string;\n  position: number;\n  readPosition: number;\n  ch: ?string;\n  constructor(input: string) {\n    this.input = input || '';\n    this.position = this.readPosition = 0;\n    this.readChar();\n  }\n  readChar() {\n    if (this.readPosition >= this.input.length) {\n      this.ch = null;\n    } else {\n      this.ch = this.input[this.readPosition];\n    }\n    this.position = this.readPosition;\n    this.readPosition += 1;\n  }\n  peekChar(): ?string {\n    if (this.readPosition >= this.input.length) {\n      return null;\n    }\n    return this.input[this.readPosition];\n  }\n  nextToken(): Token {\n    let tok: Token;\n    this.skipWhitespace();\n\n    switch (this.ch) {\n      case '=':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literial = ((ch: any): string) + ((this.ch: any): string);\n          tok = generateToken(EQ, literial);\n        } else {\n          tok = generateToken(ASSIGN, this.ch);\n        }\n        break;\n      case ';':\n        tok = generateToken(SEMICOLON, this.ch);\n        break;\n      case '(':\n        tok = generateToken(LPAREN, this.ch);\n        break;\n      case ')':\n        tok = generateToken(RPAREN, this.ch);\n        break;\n      case ',':\n        tok = generateToken(COMMA, this.ch);\n        break;\n      case '+':\n        tok = generateToken(PLUS, this.ch);\n        break;\n      case '{':\n        tok = generateToken(LBRACE, this.ch);\n        break;\n      case '}':\n        tok = generateToken(RBRACE, this.ch);\n        break;\n      case '-':\n        tok = generateToken(MINUS, this.ch);\n        break;\n      case '!':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literial = ((ch: any): string) + ((this.ch: any): string);\n          tok = generateToken(NOT_EQ, literial);\n        } else {\n          tok = generateToken(BANG, this.ch);\n        }\n        break;\n      case '/':\n        tok = generateToken(SLASH, this.ch);\n        break;\n      case '*':\n        tok = generateToken(ASTERISK, this.ch);\n        break;\n      case '<':\n        tok = generateToken(LT, this.ch);\n        break;\n      case '>':\n        tok = generateToken(GT, this.ch);\n        break;\n      case null:\n        tok = generateToken(EOF);\n        break;\n      default:\n        if (isLiterial(this.ch)) {\n          const literial = this.readIdentifier();\n          tok = generateToken(lookupIdent(literial), literial);\n          return tok;\n        } else if (isDigit(this.ch)) {\n          tok = generateToken(INT, this.readNumber());\n          return tok;\n        } else {\n          tok = generateToken(ILLEGAL, this.ch);\n        }\n    }\n    this.readChar();\n    return ((tok: any): Token);\n  }\n  readNumber(): string {\n    const position = this.position;\n    while (isDigit(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  readIdentifier(): string {\n    const position = this.position;\n    while (isLiterial(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  skipWhitespace() {\n    while (\n      this.ch === ' ' ||\n      this.ch === '\\t' ||\n      this.ch === '\\n' ||\n      this.ch === '\\r'\n    ) {\n      this.readChar();\n    }\n  }\n}\n","// @flow\nexport { Lexer } from './lexer';\nimport {\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  INT,\n  MINUS,\n  BANG,\n  SLASH,\n  ASTERISK,\n  LT,\n  GT,\n  EQ,\n  NOT_EQ\n} from './token';\n\nexport const TokenTypes = {\n  ASSIGN,\n  SEMICOLON,\n  LPAREN,\n  RPAREN,\n  COMMA,\n  PLUS,\n  LBRACE,\n  RBRACE,\n  EOF,\n  IDENT,\n  ILLEGAL,\n  INT,\n  MINUS,\n  BANG,\n  SLASH,\n  ASTERISK,\n  LT,\n  GT,\n  EQ,\n  NOT_EQ\n};\n\nexport { Parser } from './parser';\n","// @flow\n\nimport * as lexer from './lexer';\nimport * as ast from './ast';\nimport * as token from './token';\n\nexport class Parser {\n  l: lexer.Lexer;\n  curToken: token.Token;\n  peekToken: token.Token;\n  errors: Array<string>;\n  constructor(l: lexer.Lexer) {\n    this.errors = [];\n    this.l = l;\n    this.nextToken();\n    this.nextToken();\n  }\n  nextToken() {\n    this.curToken = this.peekToken;\n    this.peekToken = this.l.nextToken();\n  }\n  parseProgram(): ast.Program {\n    const program = new ast.Program();\n    debugger;\n    while (this.curToken.Type !== token.EOF) {\n      const stmt = this.parseStatememt();\n      if (stmt) {\n        program.statements.push(stmt);\n      }\n      this.nextToken();\n    }\n    return program;\n  }\n  parseStatememt(): ?ast.Statement {\n    switch (this.curToken.Type) {\n      case token.LET:\n        return this.parseLetStatement();\n      default:\n        return null;\n    }\n  }\n  parseLetStatement(): ?ast.LetStatement {\n    const stmt = new ast.LetStatement();\n    stmt.token = this.curToken;\n    if (!this.expectPeek(token.IDENT)) {\n      return;\n    }\n    stmt.name = new ast.Identifier(this.curToken, this.curToken.Literial);\n    if (!this.expectPeek(token.ASSIGN)) {\n      return;\n    }\n    // @TODO\ndebugger;\n    while (\n      this.curToken.Type !== token.EOF &&\n      !this.curTokenIs(token.SEMICOLON)\n    ) {\n      this.nextToken();\n    }\n    return stmt;\n  }\n  expectPeek(t: token.TokenType): boolean {\n    if (this.peekTokenIs(t)) {\n      this.nextToken();\n      return true;\n    } else {\n      this.peekError(t);\n      return false;\n    }\n  }\n\n  peekError(t: token.TokenType) {\n    this.errors.push(\n      `expected next token to be ${t} but got ${this.peekToken.Type}`\n    );\n  }\n  peekTokenIs(t: token.TokenType): boolean {\n    return this.peekToken.Type === t;\n  }\n  curTokenIs(t: token.TokenType): boolean {\n    return this.curToken.Type === t;\n  }\n}\n","// @flow\nexport type TokenType = string;\n\nexport interface Token {\n  Type: TokenType;\n  Literial: ?string;\n}\n\nexport function generateToken(tokenType: TokenType, literial: ?string): Token {\n  return {\n    Type: tokenType,\n    Literial: literial\n  };\n}\n\nexport const ILLEGAL = 'ILLEGAL';\nexport const EOF = 'EOF';\nexport const IDENT = 'ident';\nexport const INT = 'int';\nexport const ASSIGN = '=';\nexport const PLUS = '+';\nexport const COMMA = ',';\nexport const SEMICOLON = ';';\nexport const LPAREN = '(';\nexport const RPAREN = ')';\nexport const LBRACE = '{';\nexport const RBRACE = '}';\nexport const FUNC = 'function';\nexport const LET = 'let';\nexport const MINUS = '-';\nexport const BANG = '!';\nexport const ASTERISK = '*';\nexport const SLASH = '/';\nexport const LT = '<';\nexport const GT = '>';\nexport const TRUE = 'true';\nexport const FALSE = 'false';\nexport const IF = 'if';\nexport const ELSE = 'else';\nexport const RETURN = 'return';\nexport const EQ = '==';\nexport const NOT_EQ = '!=';\n\nexport const keywords = {\n  fn: FUNC,\n  let: LET,\n  true: TRUE,\n  false: FALSE,\n  if: IF,\n  else: ELSE,\n  return: RETURN\n};\n\nexport function lookupIdent(ident: string) {\n  const tokenType = keywords[ident];\n  if (tokenType) {\n    return tokenType;\n  }\n  return IDENT;\n}\n"],"sourceRoot":""}